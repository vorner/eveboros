//! Error handling of EveBoros.
use std::convert::From;
use std::io;
use std::fmt;
use std::error::Error as StdError;
use nix;

/// An EveBoros error.
///
/// This is generated by many routines in this library. It also sometimes wraps errors from
/// underlying libraries.
///
/// Furthermore, the `User` field allows the callbacks to propagate any other errors.
#[derive(Debug)]
pub enum Error {
    /// An embedded IO error from some low-level operation
    Io(io::Error),
    /// An embedded nix error
    Nix(nix::Error),
    /// The default implementation called
    ///
    /// You likely registered for something but haven't implemented the receiver.
    DefaultImpl,
    /// An event waits recursively for itself
    DeadLock,
    /// The referred event is not there
    Missing,
    /// The referred IO is not there or not belonging to the current event
    MissingIo,
    /// The referred event is currently in the middle of a callback and
    /// can't be bothered right now (you know, recursion).
    Busy,
    /// The loop is empty and tries to run
    Empty,
    /// The requested IO is of a different type
    IoType,
    /// The requested type of the message does not match (when extracting)
    MsgType,
    /// Message type not expected, can't send
    MsgUnexpected,
    /// The recipient loop of the Channel was destroyed
    LoopGone,
    /// The background task panicked
    BackgroundPanicked,
    /// An end of background iterator (not really an error, kind of expected to happen)
    IterEnd,
    /// This is never generated by the library itself, but it allows the callback to pass any error
    /// inside.
    User(Option<Box<StdError + 'static + Send>>),
    /// Similar to `User`, but contains a string describing the error.
    UserStr(String),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}

impl StdError for Error {
    fn description(&self) -> &str {
        match self {
            &Error::Io(ref io) => io.description(),
            &Error::Nix(ref nix) => nix.description(),
            &Error::DefaultImpl => "The default Event implementation called (if you register something, handle it)",
            &Error::DeadLock => "An event recursively waits for itself to finish",
            &Error::Missing => "Referring to a non-existing event",
            &Error::MissingIo => "Referring to a non-existing IO",
            &Error::Busy => "Can't call callbacks on an event that is already in a callback",
            &Error::Empty => "The event loop has no events and wants to run (it would never finish",
            &Error::IoType => "The requested IO is of a different type",
            &Error::MsgType => "The message is of a different type",
            &Error::MsgUnexpected => "Sending a message of a type not expected by the event",
            &Error::LoopGone => "The loop the Channel leads to no longer exists",
            &Error::BackgroundPanicked => "The background task panicked",
            &Error::IterEnd => "An iterator ended (which may be OK)",
            &Error::User(None) => "User error (no content)",
            &Error::User(Some(ref err)) => err.description(),
            &Error::UserStr(ref string) => &string,
        }
    }
    fn cause(&self) -> Option<&StdError> {
        match self {
            &Error::Io(ref io) => Some(io),
            &Error::Nix(ref nix) => Some(nix),
            &Error::User(Some(ref err)) => err.cause(),
            _ => None,
        }
    }
}

impl From<io::Error> for Error {
    fn from(e: io::Error) -> Self {
        Error::Io(e)
    }
}

impl From<nix::Error> for Error {
    fn from(e: nix::Error) -> Self {
        Error::Nix(e)
    }
}

/// A result for EveBoros operations that may fail.
pub type Result<T> = ::std::result::Result<T, Error>;
